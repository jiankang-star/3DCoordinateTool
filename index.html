<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - convex geometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - convex geometry</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<!-- <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->

		<!-- <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script> -->

		<script src="./js/three.js"></script>
		<script type="module">

			// import * as THREE from 'three';
			import { OrbitControls } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js";
			import { ConvexGeometry } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/geometries/ConvexGeometry.js"
			import * as BufferGeometryUtils from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/utils/BufferGeometryUtils.js';

			let coordinate1, coordinate2, camera, scene, renderer;

			class Coordinate3D extends THREE.Object3D {
				constructor( origin = new THREE.Vector3( 0, 0, 0), axis_length = 20, axis_radius = 0.1, quaternion = new THREE.Quaternion(0, 0, 0, 1), 
							xAxisColor = 0xff0000, yAxisColor = 0x00ff00, zAxisColor = 0x0000ff) {

					super();
					this.type = 'Coordinate3D';
					this.group = new THREE.Group()

					// add x axis
					const x_axis_geometry = new THREE.CylinderGeometry( axis_radius, axis_radius, axis_length, 32 );
					const x_axis_material = new THREE.MeshBasicMaterial( {color: xAxisColor} );
					const x_axis_cylinder = new THREE.Mesh( x_axis_geometry, x_axis_material );
					x_axis_cylinder.rotation.z = Math.PI/2;
					x_axis_cylinder.position.set(0.5*axis_length, 0, 0);
					this.group.add( x_axis_cylinder );
					
					// add x axis arrow
					const xArrowGeometry = new THREE.CylinderGeometry(0, 2*axis_radius, 8*axis_radius, 32, 1);
					this.xArrow = new THREE.Mesh( xArrowGeometry, new THREE.MeshBasicMaterial({color: xAxisColor}));
					this.xArrow.rotation.z = - Math.PI/2;
					this.xArrow.position.set(axis_length + 4*axis_radius, 0, 0);
					this.group.add( this.xArrow );

					// add y axis
					const y_axis_geometry = new THREE.CylinderGeometry( axis_radius, axis_radius, axis_length, 32 );
					const y_axis_material = new THREE.MeshBasicMaterial( {color: yAxisColor} );
					const y_axis_cylinder = new THREE.Mesh( y_axis_geometry, y_axis_material );
					y_axis_cylinder.position.set(0, 0.5*axis_length, 0);
					this.group.add( y_axis_cylinder );

					// add y axis arrow
					const yArrowGeometry = new THREE.CylinderGeometry(0, 2*axis_radius, 8*axis_radius, 32, 1);
					this.yArrow = new THREE.Mesh( xArrowGeometry, new THREE.MeshBasicMaterial({color: yAxisColor}));
					this.yArrow.position.set(0, axis_length + 4*axis_radius, 0);
					this.group.add( this.yArrow );

					// add z axis
					const z_axis_geometry = new THREE.CylinderGeometry( axis_radius, axis_radius, axis_length, 32 );
					const z_axis_material = new THREE.MeshBasicMaterial( {color: zAxisColor} );
					const z_axis_cylinder = new THREE.Mesh( z_axis_geometry, z_axis_material );
					z_axis_cylinder.rotation.x = Math.PI/2;
					z_axis_cylinder.position.set( 0, 0, 0.5*axis_length );
					this.group.add( z_axis_cylinder );

					// add z axis arrow
					const zArrowGeometry = new THREE.CylinderGeometry(0, 2*axis_radius, 8*axis_radius, 32, 1);
					this.zArrow = new THREE.Mesh( xArrowGeometry, new THREE.MeshBasicMaterial({color: zAxisColor}));					
					this.zArrow.rotation.x = Math.PI/2;
					this.zArrow.position.set(0, 0, axis_length + 4*axis_radius);
					this.group.add( this.zArrow );

					this.group.position.copy( origin );

					this.add(this.group);
				}
			}

			init();
			animate();

			function init() {

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				THREE.Object3D.DefaultUp = new THREE.Vector3(0,0,1);

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( -60, -30, 40 );
				scene.add( camera );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 500;
				controls.maxPolarAngle = 2*Math.PI;

				// ambient light
				scene.add( new THREE.AmbientLight( 0x222222 ) );

				// point light
				const light = new THREE.PointLight( 0xffffff, 1 );
				camera.add( light );

				// add coordinates
				let axis_length = 20;
				let axis_radius = 0.1;
				let axis_head_length = 0.8;
				let axis_head_width = 0.5;

				coordinate1 = new Coordinate3D();
				scene.add( coordinate1 );

				coordinate2 = new Coordinate3D(origin = new THREE.Vector3( 5, 5, 5 ), axis_length = 10);
				scene.add(coordinate2);

				// helper
				const grid = new THREE.GridHelper( 40, 40, 0x555555, 0x333333 );
				grid.rotation.x = Math.PI/2;
				scene.add( grid );

				// event
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				// coordinate1.group.rotation.z += 0.002;
				// coordinate1.group.rotation.x += 0.002;

				// coordinate2.group.rotation.y += 0.002;
				// coordinate2.group.rotation.x += 0.002;

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
