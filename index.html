<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Coordinate3D</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info"> 3D COORDINATE TOOL - <a href="https://github.com/jiankang-star/3DCoordinateTool" target="_blank" rel="noopener">alex design</a> </div>

		<form name="transform_data">
			<!-- <input type="text", name="welcom", id="test01", value=""> -->
			<div class="alive-wrapper">

				<!-- Tab links -->
				<div class="tab">
					<button type="button" class="tablinks" id="QuaternionButton" >Quaternion</button>
					<button type="button" class="tablinks" id="MatrixButton" >Matrix</button>
					<button type="button" class="tablinks" id="EulerButton" >Euler</button>
				</div>
				
				<!-- Tab content -->
				<div id="Quaternion" class="tabcontent" style="display: none;">
					<input type="text", class="input_box", name="quat_input", id="quat_id", value="">
				</div>
				
				<div id="Matrix" class="tabcontent" style="display: none;">
					<input type="text", class="input_box", name="matrix_input", id="matrix_id", value="">
				</div>
				
				<div id="Euler" class="tabcontent" style="display: none;">
					<input type="text", class="input_box", name="euler_input", id="euler_id", value="">
				</div>


				<!-- <input type="text", name="welcom", id="test01", value=""> -->
			</div>



		</form>

		<script src="./js/three.js"></script>
		<script type="module">

			import { OrbitControls } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js";
			import { ConvexGeometry } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/geometries/ConvexGeometry.js"
			import * as BufferGeometryUtils from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/utils/BufferGeometryUtils.js';

			let coordinate1, coordinate2, camera, scene, renderer;

			document.getElementById("quat_id").addEventListener("input", function(evt){transform(evt);});	// test data: 0.25881905, 0., 0., 0.96592583

			function transform(evt) {
				let input_string = evt.currentTarget.value;

				console.log(input_string);

				const value = input_string.split(",").map(Number);

				const quat = new THREE.Quaternion().fromArray(value);
				console.log(quat);
				coordinate2.group.setRotationFromQuaternion( quat );
				// coordinate2.group.position.set(-10, -10, -10);
			}

			document.getElementById("QuaternionButton").addEventListener('click', function(event){openCity(event, "Quaternion")});
			document.getElementById("MatrixButton").addEventListener('click', function(event){openCity(event, "Matrix")});
			document.getElementById("EulerButton").addEventListener('click', function(event){openCity(event, "Euler")});

			function openCity(evt, cityName) {

				// 声明所有变量
				var i, tabcontent, tablinks;

				// 使用 class="tabcontent" 获取所有元素并隐藏它们
				tabcontent = document.getElementsByClassName("tabcontent");
				for (i = 0; i < tabcontent.length; i++) {
					tabcontent[i].style.display = "none";
				}

				// 获取所有带有 class="tablinks" 的元素并删除类 "active"
				tablinks = document.getElementsByClassName("tablinks");
				for (i = 0; i < tablinks.length; i++) {
					tablinks[i].className = tablinks[i].className.replace(" active", "");
				}

				// 显示当前选项卡，并添加"活动"选项卡 类到打开选项卡的按钮
				document.getElementById(cityName).style.display = "block";
				evt.currentTarget.className += " active";
			}


			class Coordinate3D extends THREE.Object3D {
				constructor( origin = new THREE.Vector3( 0, 0, 0), axis_length = 20, axis_radius = 0.1, quaternion = new THREE.Quaternion(0, 0, 0, 1), 
							xAxisColor = 0xff0000, yAxisColor = 0x00ff00, zAxisColor = 0x0000ff) {

					super();
					this.type = 'Coordinate3D';
					this.group = new THREE.Group()

					// add x axis
					const x_axis_geometry = new THREE.CylinderGeometry( axis_radius, axis_radius, axis_length, 32 );
					const x_axis_material = new THREE.MeshBasicMaterial( {color: xAxisColor} );
					const x_axis_cylinder = new THREE.Mesh( x_axis_geometry, x_axis_material );
					x_axis_cylinder.rotation.z = Math.PI/2;
					x_axis_cylinder.position.set(0.5*axis_length, 0, 0);
					this.group.add( x_axis_cylinder );
					
					// add x axis arrow
					const xArrowGeometry = new THREE.CylinderGeometry(0, 2*axis_radius, 8*axis_radius, 32, 1);
					this.xArrow = new THREE.Mesh( xArrowGeometry, new THREE.MeshBasicMaterial({color: xAxisColor}));
					this.xArrow.rotation.z = - Math.PI/2;
					this.xArrow.position.set(axis_length + 4*axis_radius, 0, 0);
					this.group.add( this.xArrow );

					// add y axis
					const y_axis_geometry = new THREE.CylinderGeometry( axis_radius, axis_radius, axis_length, 32 );
					const y_axis_material = new THREE.MeshBasicMaterial( {color: yAxisColor} );
					const y_axis_cylinder = new THREE.Mesh( y_axis_geometry, y_axis_material );
					y_axis_cylinder.position.set(0, 0.5*axis_length, 0);
					this.group.add( y_axis_cylinder );

					// add y axis arrow
					const yArrowGeometry = new THREE.CylinderGeometry(0, 2*axis_radius, 8*axis_radius, 32, 1);
					this.yArrow = new THREE.Mesh( xArrowGeometry, new THREE.MeshBasicMaterial({color: yAxisColor}));
					this.yArrow.position.set(0, axis_length + 4*axis_radius, 0);
					this.group.add( this.yArrow );

					// add z axis
					const z_axis_geometry = new THREE.CylinderGeometry( axis_radius, axis_radius, axis_length, 32 );
					const z_axis_material = new THREE.MeshBasicMaterial( {color: zAxisColor} );
					const z_axis_cylinder = new THREE.Mesh( z_axis_geometry, z_axis_material );
					z_axis_cylinder.rotation.x = Math.PI/2;
					z_axis_cylinder.position.set( 0, 0, 0.5*axis_length );
					this.group.add( z_axis_cylinder );

					// add z axis arrow
					const zArrowGeometry = new THREE.CylinderGeometry(0, 2*axis_radius, 8*axis_radius, 32, 1);
					this.zArrow = new THREE.Mesh( xArrowGeometry, new THREE.MeshBasicMaterial({color: zAxisColor}));					
					this.zArrow.rotation.x = Math.PI/2;
					this.zArrow.position.set(0, 0, axis_length + 4*axis_radius);
					this.group.add( this.zArrow );

					this.group.position.copy( origin );

					this.add(this.group);
				}
			}

			init();
			animate();

			function init() {

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				THREE.Object3D.DefaultUp = new THREE.Vector3(0,0,1);

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( -60, -30, 40 );
				scene.add( camera );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 500;
				controls.maxPolarAngle = 2*Math.PI;

				// ambient light
				scene.add( new THREE.AmbientLight( 0x222222 ) );

				// point light
				const light = new THREE.PointLight( 0xffffff, 1 );
				camera.add( light );

				// add coordinates
				let axis_length = 20;
				let axis_radius = 0.1;
				let axis_head_length = 0.8;
				let axis_head_width = 0.5;

				// coordinate1 = new Coordinate3D(origin = new THREE.Vector3( 0, 0, 0 ), axis_length = 10, axis_radius = 0.1, quaternion = new THREE.Quaternion(0, 0, 0, 1), 
				// 			xAxisColor = 0xff0000, yAxisColor = 0x00ff00, zAxisColor = 0x0000ff);
				coordinate1 = new Coordinate3D(origin = new THREE.Vector3( 0, 0, 0 ), axis_length = 10, axis_radius = 0.1, new THREE.Quaternion(0, 0, 0, 1), 
							0x880000, 0x008800, 0x000088);
				scene.add( coordinate1 );

				coordinate2 = new Coordinate3D(origin = new THREE.Vector3( 5, 5, 5 ), axis_length = 10, axis_radius = 0.1, new THREE.Quaternion(0.65028784,  0,  0, -0.75968791));
				scene.add(coordinate2);

				// helper
				const grid = new THREE.GridHelper( 160, 40, 0x555555, 0x333333 );
				grid.rotation.x = Math.PI/2;
				scene.add( grid );

				// event
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				// coordinate1.group.rotation.z += 0.002;
				// coordinate1.group.rotation.x += 0.002;

				// coordinate2.group.rotation.y += 0.002;
				// coordinate2.group.rotation.x += 0.002;

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
